--[[
LazyLua ver1.0.0.
by ikunactrl.
Starttime: 2025/10/17
Release date of this version: 2025/10/18

This project is licensed under the MIT License. See https://opensource.org/licenses/MIT
for details.
--]]

LazyLua = {} function Mathinit() LazyLua.Math = {} local function mathadd(a, b) a = LazyLua.Math.normalize(a) b = LazyLua.Math.normalize(b) if LazyLua.Math.lessThan(a, '0') then error("mathadd: a must be >= 0, but got a=" .. a) end if LazyLua.Math.lessThan(b, '0') then error("mathadd: b must be >= 0, but got b=" .. b) end local i = #a local c = 1 local A = {} while i > 0 do A[c] = string.sub(a, i, i) c = c + 1 i = i - 1 end i = #b c = 1 local B = {} while i > 0 do B[c] = string.sub(b, i, i) c = c + 1 i = i - 1 end i = 1 local carry = 0 local result = {} local digitA = 0 local digitB = 0 local total = 0 local digit = 0 while i <= #A or i <= #B or carry == 1 do digitA = 0 digitB = 0 if i <= #A then digitA = math.floor(A[i]) end if i <= #B then digitB = math.floor(B[i]) end total = math.floor(digitA + digitB + carry) digit = total % 10 carry = math.floor(total / 10) result[i] = digit i = i + 1 end local resstr = "" for j = #result, 1, -1 do resstr = resstr .. result[j] end return LazyLua.Math.normalize(resstr) end local function mathsub(a, b) if LazyLua.Math.lessThan(a, b) then error("mathsub: a must be >= b, but got a=" .. a .. ", b=" .. b) end local i = #a local c = 1 local A = {} while i > 0 do A[c] = string.sub(a, i, i) c = c + 1 i = i - 1 end i = #b c = 1 local B = {} while i > 0 do B[c] = string.sub(b, i, i) c = c + 1 i = i - 1 end i = 1 local borrow = 0 local result = {} local digitA = 0 local digitB = 0 local diff = 0 while i <= #A do digitA = A[i] digitB = 0 if i <= #B then digitB = B[i] end diff = math.floor(digitA - digitB - borrow) if diff < 0 then diff = diff + 10 borrow = 1 else borrow = 0 end result[i] = diff i = i + 1 end local resstr = "" for j = #result, 1, -1 do resstr = resstr .. result[j] end return LazyLua.Math.normalize(resstr) end local function mathmul(a, b) a = LazyLua.Math.normalize(a) b = LazyLua.Math.normalize(b) if LazyLua.Math.lessThan(a, '0') then error("mathmul: a must be >= 0, but got a=" .. a) end if LazyLua.Math.lessThan(b, '0') then error("mathmul: b must be >= 0, but got b=" .. b) end a = LazyLua.Math.normalize(a) b = LazyLua.Math.normalize(b) if a == '0' or b == '0' then return '0' end local lenA, lenB = #a, #b local result = {} for i = 1, lenA do local digitA = tonumber(a:sub(lenA - i + 1, lenA - i + 1)) local carry = 0 for j = 1, lenB do local digitB = tonumber(b:sub(lenB - j + 1, lenB - j + 1)) local pos = i + j - 1 local temp = (result[pos] or 0) + digitA * digitB + carry result[pos] = temp % 10 carry = math.floor(temp / 10) end local pos = i + lenB while carry > 0 do local temp = (result[pos] or 0) + carry result[pos] = temp % 10 carry = math.floor(temp / 10) pos = pos + 1 end end local resstr = "" local leading = true for i = #result, 1, -1 do if leading and result[i] == 0 then else leading = false resstr = resstr .. result[i] end end return LazyLua.Math.normalize(resstr) end local function mathdiv(a, b) if b == "0" then error("mathdiv: division by zero") end if a == "0" then return "0" end a = LazyLua.Math.normalize(a) b = LazyLua.Math.normalize(b) if LazyLua.Math.greaterThan(b, a) then return "0" end local quotient = "0" while LazyLua.Math.greaterThanOrEqual(a, b) do local factor = "1" local currentB = b while true do local nextB = LazyLua.Math.mul(currentB, "10") if LazyLua.Math.greaterThan(nextB, a) then break end currentB = nextB factor = LazyLua.Math.mul(factor, "10") end a = LazyLua.Math.sub(a, currentB) quotient = LazyLua.Math.add(quotient, factor) end return LazyLua.Math.normalize(quotient) end function LazyLua.Math.normalize(s) if s == "" then return "0" end local neg = false local i = 1 if string.sub(s, 1, 1) == '-' then neg = true i = 2 end while i <= #s and string.sub(s, i, i) == '0' do i = i + 1 end if i > #s then return "0" end local numPart = string.sub(s, i) if numPart == "0" then return "0" end return (neg and "-" or "") .. numPart end function LazyLua.Math.greaterThan(a, b) if a == b then return false end if string.sub(a, 1, 1) == '-' and string.sub(b, 1, 1) ~= '-' then return false end if string.sub(a, 1, 1) ~= '-' and string.sub(b, 1, 1) == '-' then return true end if string.sub(a, 1, 1) == '-' and string.sub(b, 1, 1) == '-' then if #a == #b then for i = 2, #a do local digitA = string.sub(a, i, i) local digitB = string.sub(b, i, i) if digitA < digitB then return true elseif digitA > digitB then return false end end end return #a < #b end return not LazyLua.Math.greaterThan('-' .. a, '-' .. b) end function LazyLua.Math.lessThan(a, b) return not LazyLua.Math.greaterThan(a, b) and a ~= b end function LazyLua.Math.greaterThanOrEqual(a, b) return LazyLua.Math.greaterThan(a, b) or a == b end function LazyLua.Math.lessThanOrEqual(a, b) return not LazyLua.Math.greaterThan(a, b) or a == b end function LazyLua.Math.add(a, b) local a1 = string.sub(a, 1, 1) local b1 = string.sub(b, 1, 1) if a1 == '-' and b1 ~= '-' then return LazyLua.Math.sub(b, string.sub(a, 2)) end if a1 ~= '-' and b1 == '-' then return LazyLua.Math.sub(a, string.sub(b, 2)) end if a1 == '-' and b1 == '-' then return '-' .. mathadd(string.sub(a, 2), string.sub(b, 2)) end return mathadd(a, b) end function LazyLua.Math.sub(a, b) local a1 = string.sub(a, 1, 1) local b1 = string.sub(b, 1, 1) if a1 == '-' and b1 ~= '-' then return '-' .. mathadd(string.sub(a, 2), b) end if a1 ~= '-' and b1 == '-' then return mathadd(a, string.sub(b, 2)) end if a1 == '-' and b1 == '-' then return LazyLua.Math.sub(string.sub(b, 2), string.sub(a, 2)) end if LazyLua.Math.greaterThan(b, a) then return '-' .. mathsub(b, a) end return mathsub(a, b) end function LazyLua.Math.mul(a, b) local a1 = string.sub(a, 1, 1) local b1 = string.sub(b, 1, 1) if a1 == '-' and b1 == '-' then a = string.sub(a, 2) b = string.sub(b, 2) return mathmul(a, b) end if a1 == '-' or b1 == '-' then if a1 == '-' then a = string.sub(a, 2) end if b1 == '-' then b = string.sub(b, 2) end return '-' .. mathmul(a, b) end return mathmul(a, b) end function LazyLua.Math.div(a, b) local a1 = string.sub(a, 1, 1) local b1 = string.sub(b, 1, 1) if a1 == '-' and b1 == '-' then a = string.sub(a, 2) b = string.sub(b, 2) return mathdiv(a, b) end if a1 == '-' or b1 == '-' then if a1 == '-' then a = string.sub(a, 2) end if b1 == '-' then b = string.sub(b, 2) end return '-' .. mathdiv(a, b) end return mathdiv(a, b) end end function Stringinit() LazyLua.String = {} function LazyLua.String.at(str, index) local a = 0 local count = 1 local add = 0 local x = 0 while count <= #str do a = string.byte(str, count) if a < 128 then add = 1 elseif a >= 194 and a <= 223 then add = 2 elseif a >= 224 and a <= 239 then add = 3 else add = 4 end x = x + 1 if x == index then index = count break else count = count + add end end return string.sub(str, index, index + add - 1) end function LazyLua.String.charat(str, index) return LazyLua.String.at(str, math.max(index + 1, 1)) end function LazyLua.String.len(str) local a = 0 local count = 1 local add = 0 local x = 0 while count <= #str do a = string.byte(str, count) if a < 128 then add = 1 elseif a >= 194 and a <= 223 then add = 2 elseif a >= 224 and a <= 239 then add = 3 else add = 4 end x = x + 1 count = count + add end return x end function LazyLua.String.chars(str) local len = LazyLua.String.len(str) local index = 1 local function iterator(state) if index > len then return nil end local char = LazyLua.String.at(state, index) index = index + 1 return char end return iterator, str, nil end function LazyLua.String.substr(str, start, end_) if end_ == nil then end_ = LazyLua.String.len(str) end local result = "" local i = start while i <= end_ do result = result .. LazyLua.String.at(str, i) i = i + 1 end return result end function LazyLua.String.indexof(str, substr, start) if #str < #substr then return -1 end if #str == #substr then return 1 end if start == nil then start = 1 end local i = start local len = LazyLua.String.len(str) local sublen = LazyLua.String.len(substr) while i <= len do if LazyLua.String.substr(str, i, i + sublen - 1) == substr then return i end i = i + 1 end return -1 end function LazyLua.String.left(str, n) return LazyLua.String.substr(str, 1, n) end function LazyLua.String.right(str, n) return LazyLua.String.substr(str, LazyLua.String.len(str) - n, n) end function LazyLua.String.split(str, delimiter) local i = 1 local result = {} local j = 1 local start = i local delimiterlen = LazyLua.String.len(delimiter) while i <= LazyLua.String.len(str) do if LazyLua.String.substr(str, i, i + delimiterlen - 1) == delimiter then result[j] = LazyLua.String.substr(str, start, i - 1) start = i + delimiterlen j = j + 1 end i = i + 1 end result[j] = LazyLua.String.substr(str, start) return result end function LazyLua.String.join(list, separator) local result = "" for i = 1, #list do result = result .. list[i] if i < #list then result = result .. separator end end return result end function LazyLua.String.lastindexof(str, substr) if #str < #substr then return -1 end if #str == #substr then if str ~= substr then return -1 else return 1 end end local i = LazyLua.String.len(str) local sublen = LazyLua.String.len(substr) while i >= sublen do if LazyLua.String.substr(str, i - sublen + 1, i) == substr then return i - sublen + 1 end i = i - 1 end return -1 end function LazyLua.String.includes(str, substr) return LazyLua.String.indexof(str, substr) ~= -1 end function LazyLua.String.Repeat(str, n) local result = "" for i = 1, n do result = result .. str end return result end function LazyLua.String.replace(str, old, new, limit) limit = limit or -1 local result = "" local i = 1 local count = 0 local oldlen = LazyLua.String.len(old) while i <= LazyLua.String.len(str) do if LazyLua.String.substr(str, i, i + oldlen - 1) == old and (limit == -1 or count < limit) then result = result .. new i = i + oldlen count = count + 1 else result = result .. LazyLua.String.at(str, i) i = i + 1 end end return result end function LazyLua.String.to2DTable(text, rowSep, colSep) rowSep = rowSep or "\n" colSep = colSep or "," local rows = LazyLua.String.split(text, rowSep) local tableResult = {} for i = 1, #rows do tableResult[i] = LazyLua.String.split(rows[i], colSep) end return tableResult end function LazyLua.String.column(table2D, index, default) if type(table2D) ~= "table" then error("column: table2D must be a table") end local result = {} for i = 1, #table2D do local row = table2D[i] local value = default if type(row) == "table" then if type(index) == "number" then local pos = index if pos < 0 then pos = #row + pos + 1 end value = row[pos] else value = row[index] end if value == nil then value = default end end result[#result + 1] = value end return result end end function Sortinit() LazyLua.Sort = {} LazyLua.Sort.ASC = 1 LazyLua.Sort.DESC = 2 function LazyLua.Sort.bubble(arr, method) local n = #arr if n == 0 then return {} end local arrindex = {} for i = 1, n do arrindex[i] = i end for i = 1, n - 1 do local isSorted = true for j = 1, n - i do local idx1 = arrindex[j] local idx2 = arrindex[j + 1] local val1 = arr[idx1] local val2 = arr[idx2] local a1 = false if method == LazyLua.Sort.ASC then a1 = LazyLua.Math.greaterThan(val1, val2) elseif method == LazyLua.Sort.DESC then a1 = LazyLua.Math.lessThan(val1, val2) else error("Invalid sort method: " .. tostring(method)) end if a1 then arrindex[j], arrindex[j + 1] = arrindex[j + 1], arrindex[j] isSorted = false end end if isSorted then break end end return arrindex end function LazyLua.Sort.quick(arr, method) if method == nil then method = LazyLua.Sort.ASC end local n = #arr if n == 0 then return {} end local a = {} local arrindex = {} for i = 1, n do a[i] = arr[i] arrindex[i] = i end local function swap(i, j) a[i], a[j] = a[j], a[i] arrindex[i], arrindex[j] = arrindex[j], arrindex[i] end local function partition(lo, hi) local pivot = a[hi] local i = lo for j = lo, hi - 1 do local shouldInclude = false if method == LazyLua.Sort.ASC then shouldInclude = LazyLua.Math.lessThanOrEqual(a[j], pivot) elseif method == LazyLua.Sort.DESC then shouldInclude = LazyLua.Math.greaterThanOrEqual(a[j], pivot) else error("Invalid sort method: " .. tostring(method)) end if shouldInclude then swap(i, j) i = i + 1 end end swap(i, hi) return i end local function qsort(lo, hi) if lo >= hi then return end local p = partition(lo, hi) qsort(lo, p - 1) qsort(p + 1, hi) end qsort(1, n) return arrindex end function LazyLua.Sort.applyIndices(indices, arr) local result = {} for i = 1, #indices do result[i] = arr[indices[i]] end return result end end Mathinit() Stringinit() Sortinit() return LazyLua